name: Validate Move

on:
  pull_request_target:
    branches: ['game/**', 'test-game/**']

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          fetch-depth: 0

      - name: Validate Move
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            const prAuthor = context.payload.pull_request.user.login;
            const baseRef = context.payload.pull_request.base.ref;
            const headSha = context.payload.pull_request.head.sha;

            const { execSync } = require('child_process');
            const oldState = JSON.parse(
              execSync(`git show origin/${baseRef}:game.json`).toString()
            );

            const { data: newFile } = await github.rest.repos.getContent({
              owner: context.payload.pull_request.head.repo.owner.login,
              repo: context.payload.pull_request.head.repo.name,
              path: 'game.json',
              ref: headSha
            });
            const newState = JSON.parse(Buffer.from(newFile.content, 'base64').toString());

            if (oldState.winner) {
              core.setFailed(`Game already over. Winner: ${oldState.winner}`);
              return;
            }

            const expectedPlayer = oldState.players[oldState.turn];
            if (prAuthor !== expectedPlayer) {
              core.setFailed(`Not your turn! Waiting for ${expectedPlayer}, got ${prAuthor}`);
              return;
            }

            const changes = [];
            for (let i = 0; i < 9; i++) {
              if (oldState.board[i] !== newState.board[i]) {
                changes.push({ index: i, from: oldState.board[i], to: newState.board[i] });
              }
            }

            if (changes.length !== 1) {
              core.setFailed(`Must change exactly one cell. Found ${changes.length} changes.`);
              return;
            }

            const move = changes[0];

            if (move.from !== null) {
              core.setFailed(`Cell ${move.index} already occupied by ${move.from}`);
              return;
            }

            if (move.to !== oldState.turn) {
              core.setFailed(`Wrong symbol. Expected ${oldState.turn}, got ${move.to}`);
              return;
            }

            const nextTurn = oldState.turn === 'X' ? 'O' : 'X';
            if (newState.turn !== nextTurn && !newState.winner) {
              core.setFailed(`Turn should advance to ${nextTurn}`);
              return;
            }

            const lines = [
              [0,1,2], [3,4,5], [6,7,8],
              [0,3,6], [1,4,7], [2,5,8],
              [0,4,8], [2,4,6]
            ];
            let actualWinner = null;
            for (const [a,b,c] of lines) {
              if (newState.board[a] && newState.board[a] === newState.board[b] && newState.board[b] === newState.board[c]) {
                actualWinner = newState.board[a];
                break;
              }
            }
            if (newState.board.every(c => c !== null) && !actualWinner) {
              actualWinner = 'draw';
            }

            if (newState.winner !== actualWinner) {
              core.setFailed(`Winner should be ${actualWinner}, got ${newState.winner}`);
              return;
            }

            console.log(`âœ“ Valid move by ${prAuthor}: ${oldState.turn} -> cell ${move.index}`);

            // Store game info for leaderboard update
            core.setOutput('winner', actualWinner || '');
            core.setOutput('playerX', newState.players.X);
            core.setOutput('playerO', newState.players.O);
            core.setOutput('issue', oldState.issue || '');
            core.setOutput('branch', baseRef);
            core.setOutput('lastMove', new Date().toISOString());

            // Notify the game's issue if it exists
            if (oldState.issue) {
              const board = newState.board;
              const boardStr = [
                `\`${board[0]||'Â·'}\` \`${board[1]||'Â·'}\` \`${board[2]||'Â·'}\``,
                `\`${board[3]||'Â·'}\` \`${board[4]||'Â·'}\` \`${board[5]||'Â·'}\``,
                `\`${board[6]||'Â·'}\` \`${board[7]||'Â·'}\` \`${board[8]||'Â·'}\``
              ].join('\n');

              let msg = `**${prAuthor}** played ${oldState.turn} at cell ${move.index}\n\n${boardStr}`;
              if (actualWinner === 'draw') {
                msg += `\n\nðŸ¤ **Game Over - Draw!**`;
              } else if (actualWinner) {
                msg += `\n\nðŸ† **Game Over - ${actualWinner} wins!**`;
              } else {
                msg += `\n\nâ³ ${newState.players[newState.turn]}'s turn (${newState.turn})`;
              }

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: oldState.issue,
                body: msg
              });
            }

      - name: Update leaderboard
        if: success() && startsWith(github.event.pull_request.base.ref, 'game/')
        uses: actions/github-script@v7
        with:
          script: |
            const winner = '${{ steps.validate.outputs.winner }}';
            const playerX = '${{ steps.validate.outputs.playerX }}';
            const playerO = '${{ steps.validate.outputs.playerO }}';
            const issue = '${{ steps.validate.outputs.issue }}';
            const branch = '${{ steps.validate.outputs.branch }}';
            const lastMove = '${{ steps.validate.outputs.lastMove }}';
            const gameOver = winner !== '';

            // Fetch current leaderboard from main
            let leaderboard, leaderboardSha;
            try {
              const { data: file } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'leaderboard.json',
                ref: 'main'
              });
              leaderboard = JSON.parse(Buffer.from(file.content, 'base64').toString());
              leaderboardSha = file.sha;
            } catch (e) {
              leaderboard = { players: {}, recentGames: [], activeGames: [] };
            }
            if (!leaderboard.activeGames) leaderboard.activeGames = [];

            if (gameOver) {
              if (!leaderboard.players[playerX]) {
                leaderboard.players[playerX] = { wins: 0, losses: 0, draws: 0 };
              }
              if (!leaderboard.players[playerO]) {
                leaderboard.players[playerO] = { wins: 0, losses: 0, draws: 0 };
              }
              if (winner === 'draw') {
                leaderboard.players[playerX].draws++;
                leaderboard.players[playerO].draws++;
              } else if (winner === 'X') {
                leaderboard.players[playerX].wins++;
                leaderboard.players[playerO].losses++;
              } else if (winner === 'O') {
                leaderboard.players[playerO].wins++;
                leaderboard.players[playerX].losses++;
              }
              leaderboard.recentGames.unshift({
                players: [playerX, playerO],
                winner: winner,
                branch: branch,
                issue: issue ? parseInt(issue) : null,
                timestamp: lastMove
              });
              leaderboard.recentGames = leaderboard.recentGames.slice(0, 20);
              leaderboard.activeGames = leaderboard.activeGames.filter(g => g.branch !== branch);
            } else {
              const existing = leaderboard.activeGames.find(g => g.branch === branch);
              if (existing) {
                existing.lastMove = lastMove;
              } else {
                leaderboard.activeGames.push({
                  players: [playerX, playerO],
                  branch: branch,
                  issue: issue ? parseInt(issue) : null,
                  lastMove: lastMove
                });
              }
            }

            // Update leaderboard.json
            const leaderboardContent = Buffer.from(JSON.stringify(leaderboard, null, 2) + '\n').toString('base64');
            const msg = gameOver
              ? `Leaderboard: ${playerX} vs ${playerO} â†’ ${winner}`
              : `Leaderboard: ${playerX} vs ${playerO} move`;
            const { data: updatedFile } = await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'leaderboard.json',
              message: msg,
              content: leaderboardContent,
              sha: leaderboardSha,
              branch: 'main'
            });
            console.log(`âœ“ Leaderboard JSON updated`);

            // Render leaderboard markdown
            const formatDate = (ts) => {
              const d = new Date(ts);
              return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            };
            const formatResult = (g) => {
              if (g.winner === 'draw') return 'ðŸ¤';
              const winnerName = g.winner === 'X' ? g.players[0] : g.players[1];
              return `ðŸ† ${winnerName}`;
            };

            let md = '';
            if (leaderboard.activeGames.length > 0) {
              md += `### ðŸŽ® Active Games\n\n`;
              md += `| Players | Last Move |\n|---------|----------|\n`;
              for (const g of leaderboard.activeGames.slice(0, 5)) {
                const issueLink = g.issue ? `[#${g.issue}](../../issues/${g.issue})` : '';
                md += `| ${g.players[0]} vs ${g.players[1]} ${issueLink} | ${formatDate(g.lastMove)} |\n`;
              }
              md += '\n';
            }
            if (leaderboard.recentGames.length > 0) {
              md += `### ðŸ Recent Games\n\n`;
              md += `| Players | Result | Date |\n|---------|--------|------|\n`;
              for (const g of leaderboard.recentGames.slice(0, 10)) {
                const issueLink = g.issue ? `[#${g.issue}](../../issues/${g.issue})` : '';
                md += `| ${g.players[0]} vs ${g.players[1]} ${issueLink} | ${formatResult(g)} | ${formatDate(g.timestamp)} |\n`;
              }
              md += '\n';
            }
            const playerList = Object.entries(leaderboard.players)
              .map(([name, stats]) => ({ name, ...stats, score: stats.wins * 3 + stats.draws }))
              .sort((a, b) => b.score - a.score);
            if (playerList.length > 0) {
              md += `### ðŸ‘‘ Top Players\n\n`;
              md += `| Player | W | L | D |\n|--------|---|---|---|\n`;
              for (const p of playerList.slice(0, 10)) {
                md += `| ${p.name} | ${p.wins} | ${p.losses} | ${p.draws} |\n`;
              }
            }

            // Update README
            const { data: readmeFile } = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'README.md',
              ref: 'main'
            });
            const readme = Buffer.from(readmeFile.content, 'base64').toString();
            const newReadme = readme.replace(
              /<!-- LEADERBOARD:START -->[\s\S]*?<!-- LEADERBOARD:END -->/,
              `<!-- LEADERBOARD:START -->\n${md}<!-- LEADERBOARD:END -->`
            );
            if (newReadme !== readme) {
              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'README.md',
                message: `Update README leaderboard`,
                content: Buffer.from(newReadme).toString('base64'),
                sha: readmeFile.sha,
                branch: 'main'
              });
              console.log(`âœ“ README updated`);
            }

      - name: Auto-merge (production games only)
        if: success() && startsWith(github.event.pull_request.base.ref, 'game/')
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              merge_method: 'merge'
            });
            console.log(`âœ“ PR #${context.payload.pull_request.number} auto-merged`);
